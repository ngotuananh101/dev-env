/**
 * Sites Handler - IPC handlers for Website/Project management
 * Handles: PHP Projects, Node Projects, Proxy Projects
 * Supports both Nginx and Apache
 */

const fs = require('fs');
const fsPromises = require('fs').promises;
const path = require('path');
const { spawn, exec } = require('child_process');

// Store running Node processes
const runningNodeProcesses = new Map();

/**
 * Generate Nginx config for a site
 */
function generateNginxConfig(site, phpPath = null) {
    const { domain, type, root_path, port, php_version, proxy_target } = site;

    let config = `# Site: ${site.name}
# Domain: ${domain}
# Type: ${type}
# Generated by Dev-Env

server {
    listen 80;
    server_name ${domain};
`;

    if (type === 'php') {
        config += `
    root "${root_path.replace(/\\/g, '/')}";
    index index.php index.html index.htm;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \\.php$ {
        fastcgi_pass 127.0.0.1:9000;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }

    location ~ /\\.ht {
        deny all;
    }
`;
    } else if (type === 'node') {
        config += `
    location / {
        proxy_pass http://127.0.0.1:${port};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
`;
    } else if (type === 'proxy') {
        config += `
    location / {
        proxy_pass ${proxy_target};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
`;
    }

    config += `}
`;
    return config;
}

/**
 * Generate Apache VirtualHost config
 */
function generateApacheConfig(site) {
    const { domain, type, root_path, port, proxy_target } = site;

    let config = `# Site: ${site.name}
# Domain: ${domain}
# Type: ${type}
# Generated by Dev-Env

<VirtualHost *:80>
    ServerName ${domain}
`;

    if (type === 'php') {
        config += `    DocumentRoot "${root_path.replace(/\\/g, '/')}"
    
    <Directory "${root_path.replace(/\\/g, '/')}">
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    <FilesMatch \\.php$>
        SetHandler "proxy:fcgi://127.0.0.1:9000"
    </FilesMatch>
`;
    } else if (type === 'node' || type === 'proxy') {
        const target = type === 'node' ? `http://127.0.0.1:${port}` : proxy_target;
        config += `    ProxyPreserveHost On
    ProxyPass / ${target}/
    ProxyPassReverse / ${target}/
`;
    }

    config += `</VirtualHost>
`;
    return config;
}

/**
 * Register sites-related IPC handlers
 */
function register(ipcMain, context) {
    const { getDbManager, appDir } = context;

    // Get list of sites
    ipcMain.handle('sites-list', async () => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites ORDER BY created_at DESC');

            // Add running status for Node projects
            for (const site of sites) {
                if (site.type === 'node') {
                    site.processRunning = runningNodeProcesses.has(site.id);
                }
            }

            return { sites: sites || [] };
        } catch (error) {
            console.error('Failed to get sites:', error);
            return { error: error.message };
        }
    });

    // Create new site
    ipcMain.handle('sites-create', async (event, siteData) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const { name, domain, type, webserver, root_path, port, php_version, node_script, proxy_target } = siteData;
            const now = new Date().toISOString();

            // Check if domain already exists
            const existing = dbManager.query('SELECT id FROM sites WHERE domain = ?', [domain]);
            if (existing && existing.length > 0) {
                return { error: 'Domain already exists' };
            }

            // Create root directory if PHP project
            if (type === 'php' && root_path) {
                if (!fs.existsSync(root_path)) {
                    await fsPromises.mkdir(root_path, { recursive: true });
                }
                // Create default index.php
                const indexPath = path.join(root_path, 'index.php');
                if (!fs.existsSync(indexPath)) {
                    await fsPromises.writeFile(indexPath, `<?php\necho '<h1>Welcome to ${name}</h1>';\nphpinfo();\n`);
                }
            }

            // Insert into database
            const result = dbManager.query(
                `INSERT INTO sites (name, domain, type, webserver, root_path, port, php_version, node_script, proxy_target, status, created_at, updated_at)
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'stopped', ?, ?)`,
                [name, domain, type, webserver, root_path || '', port || 0, php_version || '', node_script || '', proxy_target || '', now, now]
            );

            if (result.error) {
                return { error: result.error };
            }

            const siteId = result.lastInsertRowid;
            const site = { id: siteId, name, domain, type, webserver, root_path, port, php_version, node_script, proxy_target };

            // Generate and save webserver config
            await saveSiteConfig(site, appDir);

            return { success: true, id: siteId };
        } catch (error) {
            console.error('Failed to create site:', error);
            return { error: error.message };
        }
    });

    // Delete site
    ipcMain.handle('sites-delete', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            // Get site info first
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            // Stop Node process if running
            if (site.type === 'node' && runningNodeProcesses.has(siteId)) {
                const proc = runningNodeProcesses.get(siteId);
                proc.kill();
                runningNodeProcesses.delete(siteId);
            }

            // Delete config file
            await deleteSiteConfig(site, appDir);

            // Delete from database
            const result = dbManager.query('DELETE FROM sites WHERE id = ?', [siteId]);
            if (result.error) {
                return { error: result.error };
            }

            return { success: true };
        } catch (error) {
            console.error('Failed to delete site:', error);
            return { error: error.message };
        }
    });

    // Start Node project
    ipcMain.handle('sites-start-node', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            if (site.type !== 'node') {
                return { error: 'Not a Node project' };
            }

            if (runningNodeProcesses.has(siteId)) {
                return { error: 'Already running' };
            }

            // Start Node process
            const scriptPath = path.join(site.root_path, site.node_script || 'index.js');
            if (!fs.existsSync(scriptPath)) {
                return { error: `Script not found: ${scriptPath}` };
            }

            const proc = spawn('node', [scriptPath], {
                cwd: site.root_path,
                env: { ...process.env, PORT: site.port },
                stdio: 'pipe'
            });

            proc.on('error', (err) => {
                console.error(`Node process error for ${site.name}:`, err);
                runningNodeProcesses.delete(siteId);
            });

            proc.on('exit', () => {
                runningNodeProcesses.delete(siteId);
                dbManager.query('UPDATE sites SET status = ? WHERE id = ?', ['stopped', siteId]);
            });

            runningNodeProcesses.set(siteId, proc);
            dbManager.query('UPDATE sites SET status = ? WHERE id = ?', ['running', siteId]);

            return { success: true, pid: proc.pid };
        } catch (error) {
            console.error('Failed to start Node project:', error);
            return { error: error.message };
        }
    });

    // Stop Node project
    ipcMain.handle('sites-stop-node', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            if (!runningNodeProcesses.has(siteId)) {
                return { error: 'Not running' };
            }

            const proc = runningNodeProcesses.get(siteId);
            proc.kill();
            runningNodeProcesses.delete(siteId);

            dbManager.query('UPDATE sites SET status = ? WHERE id = ?', ['stopped', siteId]);

            return { success: true };
        } catch (error) {
            console.error('Failed to stop Node project:', error);
            return { error: error.message };
        }
    });

    // Get site config content
    ipcMain.handle('sites-get-config', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            const configPath = getConfigPath(site, appDir);
            if (!fs.existsSync(configPath)) {
                return { error: 'Config file not found' };
            }

            const content = await fsPromises.readFile(configPath, 'utf-8');
            return { content, path: configPath };
        } catch (error) {
            console.error('Failed to get site config:', error);
            return { error: error.message };
        }
    });

    // Save site config content
    ipcMain.handle('sites-save-config', async (event, siteId, content) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            const configPath = getConfigPath(site, appDir);
            await fsPromises.writeFile(configPath, content, 'utf-8');

            return { success: true };
        } catch (error) {
            console.error('Failed to save site config:', error);
            return { error: error.message };
        }
    });

    // Get installed webserver
    ipcMain.handle('sites-get-webserver', async () => {
        const dbManager = getDbManager();
        if (!dbManager) return { installed: null };

        try {
            // Check installed apps for nginx or apache
            const nginx = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', ['nginx']);
            const apache = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', ['apache']);

            const result = {
                nginx: nginx && nginx.length > 0 ? nginx[0] : null,
                apache: apache && apache.length > 0 ? apache[0] : null
            };

            return result;
        } catch (error) {
            console.error('Failed to check webserver:', error);
            return { error: error.message };
        }
    });

    // Open site in browser
    ipcMain.handle('sites-open-browser', async (event, domain) => {
        const { shell } = require('electron');
        await shell.openExternal(`http://${domain}`);
        return { success: true };
    });


}

/**
 * Get config file path for a site
 */
function getConfigPath(site, appDir) {
    const sitesConfigDir = path.join(appDir, 'sites');
    if (!fs.existsSync(sitesConfigDir)) {
        fs.mkdirSync(sitesConfigDir, { recursive: true });
    }

    const ext = site.webserver === 'apache' ? '.conf' : '.conf';
    return path.join(sitesConfigDir, `${site.domain}${ext}`);
}

/**
 * Save site config file
 */
async function saveSiteConfig(site, appDir) {
    const configPath = getConfigPath(site, appDir);

    let config;
    if (site.webserver === 'apache') {
        config = generateApacheConfig(site);
    } else {
        config = generateNginxConfig(site);
    }

    await fsPromises.writeFile(configPath, config, 'utf-8');
    return configPath;
}

/**
 * Delete site config file
 */
async function deleteSiteConfig(site, appDir) {
    const configPath = getConfigPath(site, appDir);
    if (fs.existsSync(configPath)) {
        await fsPromises.unlink(configPath);
    }
}



module.exports = { register, runningNodeProcesses };
