/**
 * Sites Handler - IPC handlers for Website/Project management
 * Handles: PHP Projects, Node Projects, Proxy Projects
 * Supports both Nginx and Apache
 */

const fs = require('fs');
const fsPromises = require('fs').promises;
const path = require('path');
const { spawn, exec } = require('child_process');
const { addHosts, removeHosts } = require('./hostsHandler');

// Store running Node processes
const runningNodeProcesses = new Map();

/**
 * Generate Nginx config for a site
 * @param {Object} site - Site configuration
 * @param {string} fastcgiAddress - FastCGI address (e.g., 127.0.0.1:9000)
 * @param {string} rewriteRules - Nginx rewrite rules content
 */
function generateNginxConfig(site, fastcgiAddress = '127.0.0.1:9000', rewriteRules = '') {
    const { domain, type, root_path, port, php_version, proxy_target } = site;

    let config = `# Site: ${site.name}
# Domain: ${domain}
# Type: ${type}
# Generated by Dev-Env

server {
    listen 80;
    server_name ${domain};
`;

    if (type === 'php') {
        config += `
    root "${root_path.replace(/\\/g, '/')}";
    index index.php index.html index.htm;

    # Rewrite Rules
    ${rewriteRules || ''}
    # End Rewrite Rules
    
    location ~ \\.php$ {
        fastcgi_pass ${fastcgiAddress};
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }

    location ~ /\\.ht {
        deny all;
    }
`;
    } else if (type === 'node') {
        config += `
    location / {
        proxy_pass http://127.0.0.1:${port};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
`;
    } else if (type === 'proxy') {
        config += `
    location / {
        proxy_pass ${proxy_target};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
`;
    }

    config += `}
`;
    return config;
}

/**
 * Generate Apache VirtualHost config
 * @param {Object} site - Site configuration
 * @param {string} fastcgiAddress - FastCGI address (e.g., 127.0.0.1:9000)
 */
function generateApacheConfig(site, fastcgiAddress = '127.0.0.1:9000') {
    const { domain, type, root_path, port, proxy_target } = site;

    let config = `# Site: ${site.name}
# Domain: ${domain}
# Type: ${type}
# Generated by Dev-Env

<VirtualHost *:80>
    ServerName ${domain}
`;

    if (type === 'php') {
        config += `    DocumentRoot "${root_path.replace(/\\/g, '/')}"
    
    <Directory "${root_path.replace(/\\/g, '/')}">
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    <FilesMatch \\.php$>
        SetHandler "proxy:fcgi://${fastcgiAddress}"
    </FilesMatch>
`;
    } else if (type === 'node' || type === 'proxy') {
        const target = type === 'node' ? `http://127.0.0.1:${port}` : proxy_target;
        config += `    ProxyPreserveHost On
    ProxyPass / ${target}/
    ProxyPassReverse / ${target}/
`;
    }

    config += `</VirtualHost>
`;
    return config;
}

/**
 * Register sites-related IPC handlers
 */
function register(ipcMain, context) {
    const { getDbManager, appDir } = context;

    // Get list of sites
    ipcMain.handle('sites-list', async () => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        // Ensure rewrite_template column exists
        try {
            const columns = dbManager.query('PRAGMA table_info(sites)');
            const hasRewrite = columns.some(col => col.name === 'rewrite_template');
            if (!hasRewrite) {
                dbManager.query('ALTER TABLE sites ADD COLUMN rewrite_template TEXT');
            }
        } catch (e) {
            console.error('Migration error:', e);
        }

        try {
            const sites = dbManager.query('SELECT * FROM sites ORDER BY created_at DESC');

            // Add running status for Node projects
            for (const site of sites) {
                if (site.type === 'node') {
                    site.processRunning = runningNodeProcesses.has(site.id);
                }
            }

            return { sites: sites || [] };
        } catch (error) {
            console.error('Failed to get sites:', error);
            return { error: error.message };
        }
    });

    // Create new site
    ipcMain.handle('sites-create', async (event, siteData) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const { name, domain, type, webserver, root_path, port, php_version, node_script, proxy_target } = siteData;
            const now = new Date().toISOString();

            // Check if domain already exists
            const existing = dbManager.query('SELECT id FROM sites WHERE domain = ?', [domain]);
            if (existing && existing.length > 0) {
                return { error: 'Domain already exists' };
            }

            // Create root directory if PHP project
            if (type === 'php' && root_path) {
                if (!fs.existsSync(root_path)) {
                    await fsPromises.mkdir(root_path, { recursive: true });
                }
                // Create default index.php
                const indexPath = path.join(root_path, 'index.php');
                if (!fs.existsSync(indexPath)) {
                    await fsPromises.writeFile(indexPath, `<?php\necho '<h1>Welcome to ${name}</h1>';\nphpinfo();\n`);
                }
            }

            // Default PHP version if not provided
            let finalPhpVersion = php_version;
            if (type === 'php') {
                if (!finalPhpVersion) {
                    const defaultPhp = dbManager.query('SELECT * FROM settings WHERE key = ?', ['default_php_version']);
                    finalPhpVersion = (defaultPhp && defaultPhp.length > 0) ? defaultPhp[0].value : '8.2';
                }
                finalPhpVersion = sanitizePhpVersion(finalPhpVersion);
            }

            // Insert into database
            const result = dbManager.query(
                `INSERT INTO sites (name, domain, type, webserver, root_path, port, php_version, node_script, proxy_target, status, created_at, updated_at)
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'stopped', ?, ?)`,
                [name, domain, type, webserver, root_path || '', port || 0, finalPhpVersion || '', node_script || '', proxy_target || '', now, now]
            );

            if (result.error) {
                return { error: result.error };
            }

            const siteId = result.lastInsertRowid;
            const site = { id: siteId, name, domain, type, webserver, root_path, port, php_version, node_script, proxy_target };

            // Generate and save webserver config
            await saveSiteConfig(site, appDir, dbManager);

            // Add to hosts file
            await addHosts([domain]);

            return { success: true, id: siteId };
        } catch (error) {
            console.error('Failed to create site:', error);
            return { error: error.message };
        }
    });

    // Delete site
    ipcMain.handle('sites-delete', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            // Get site info first
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            // Stop Node process if running
            if (site.type === 'node' && runningNodeProcesses.has(siteId)) {
                const proc = runningNodeProcesses.get(siteId);
                proc.kill();
                runningNodeProcesses.delete(siteId);
            }

            // Delete config file
            await deleteSiteConfig(site, appDir);

            // Remove from hosts file
            await removeHosts([site.domain]);

            // Delete from database
            const result = dbManager.query('DELETE FROM sites WHERE id = ?', [siteId]);
            if (result.error) {
                return { error: result.error };
            }

            return { success: true };
        } catch (error) {
            console.error('Failed to delete site:', error);
            return { error: error.message };
        }
    });

    // Start Node project
    ipcMain.handle('sites-start-node', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            if (site.type !== 'node') {
                return { error: 'Not a Node project' };
            }

            if (runningNodeProcesses.has(siteId)) {
                return { error: 'Already running' };
            }

            // Start Node process
            const scriptPath = path.join(site.root_path, site.node_script || 'index.js');
            if (!fs.existsSync(scriptPath)) {
                return { error: `Script not found: ${scriptPath}` };
            }

            const proc = spawn('node', [scriptPath], {
                cwd: site.root_path,
                env: { ...process.env, PORT: site.port },
                stdio: 'pipe'
            });

            proc.on('error', (err) => {
                console.error(`Node process error for ${site.name}:`, err);
                runningNodeProcesses.delete(siteId);
            });

            proc.on('exit', () => {
                runningNodeProcesses.delete(siteId);
                dbManager.query('UPDATE sites SET status = ? WHERE id = ?', ['stopped', siteId]);
            });

            runningNodeProcesses.set(siteId, proc);
            dbManager.query('UPDATE sites SET status = ? WHERE id = ?', ['running', siteId]);

            return { success: true, pid: proc.pid };
        } catch (error) {
            console.error('Failed to start Node project:', error);
            return { error: error.message };
        }
    });

    // Stop Node project
    ipcMain.handle('sites-stop-node', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            if (!runningNodeProcesses.has(siteId)) {
                return { error: 'Not running' };
            }

            const proc = runningNodeProcesses.get(siteId);
            proc.kill();
            runningNodeProcesses.delete(siteId);

            dbManager.query('UPDATE sites SET status = ? WHERE id = ?', ['stopped', siteId]);

            return { success: true };
        } catch (error) {
            console.error('Failed to stop Node project:', error);
            return { error: error.message };
        }
    });

    // Get site config content
    ipcMain.handle('sites-get-config', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            const configPath = getConfigPath(site, appDir);
            if (!fs.existsSync(configPath)) {
                return { error: 'Config file not found' };
            }

            const content = await fsPromises.readFile(configPath, 'utf-8');
            return { content, path: configPath };
        } catch (error) {
            console.error('Failed to get site config:', error);
            return { error: error.message };
        }
    });

    // Save site config content
    ipcMain.handle('sites-save-config', async (event, siteId, content) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            const configPath = getConfigPath(site, appDir);
            await fsPromises.writeFile(configPath, content, 'utf-8');

            return { success: true };
        } catch (error) {
            console.error('Failed to save site config:', error);
            return { error: error.message };
        }
    });

    // Get installed webserver
    ipcMain.handle('sites-get-webserver', async () => {
        const dbManager = getDbManager();
        if (!dbManager) return { installed: null };

        try {
            // Check installed apps for nginx or apache
            const nginx = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', ['nginx']);
            const apache = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', ['apache']);

            const result = {
                nginx: nginx && nginx.length > 0 ? nginx[0] : null,
                apache: apache && apache.length > 0 ? apache[0] : null
            };

            return result;
        } catch (error) {
            console.error('Failed to check webserver:', error);
            return { error: error.message };
        }
    });

    // Get installed PHP versions
    ipcMain.handle('sites-get-php-versions', async () => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const phpApps = dbManager.query('SELECT installed_version FROM installed_apps WHERE app_id LIKE ?', [`php%`]);
            const versions = phpApps.map(app => {
                // Extract major.minor from version string (e.g., 8.2.10 -> 8.2)
                const match = app.installed_version.match(/^(\d+\.\d+)/);
                return match ? match[1] : app.installed_version;
            });
            // Unique versions
            const uniqueVersions = [...new Set(versions)].sort().reverse();
            return { versions: uniqueVersions };
        } catch (error) {
            console.error('Failed to get PHP versions:', error);
            return { error: error.message };
        }
    });

    // Update site PHP version
    ipcMain.handle('sites-update-php', async (event, siteId, phpVersion) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            if (site.type !== 'php') {
                return { error: 'Not a PHP site' };
            }

            phpVersion = sanitizePhpVersion(phpVersion);

            // Update database
            dbManager.query('UPDATE sites SET php_version = ?, updated_at = ? WHERE id = ?', [phpVersion, new Date().toISOString(), siteId]);

            // Update site object
            site.php_version = phpVersion;

            // Regenerate config
            await saveSiteConfig(site, appDir, dbManager);

            return { success: true };
        } catch (error) {
            console.error('Failed to update PHP version:', error);
            return { error: error.message };
        }
    });

    // Get rewrite templates
    ipcMain.handle('sites-get-rewrite-templates', async () => {
        const rewriteDir = path.join(appDir, 'data', 'rewrite');
        if (!fs.existsSync(rewriteDir)) return { templates: {} };

        try {
            const files = await fsPromises.readdir(rewriteDir);
            const templates = {};
            for (const file of files) {
                if (file.endsWith('.conf')) {
                    const name = file.replace('.conf', '');
                    templates[name] = { name: name };
                }
            }
            return { templates };
        } catch (e) {
            console.error('Get rewrite templates error', e);
            return { templates: {} };
        }
    });

    // Update site rewrite template
    ipcMain.handle('sites-update-rewrite', async (event, siteId, templateName, onlyDb = false) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            if (site.type !== 'php') {
                return { error: 'Not a PHP site' };
            }

            const templatePath = path.join(appDir, 'data', 'rewrite', `${templateName}.conf`);
            if (!fs.existsSync(templatePath)) {
                return { error: 'Invalid template' };
            }

            // Update database
            dbManager.query('UPDATE sites SET rewrite_template = ?, updated_at = ? WHERE id = ?', [templateName, new Date().toISOString(), siteId]);

            // Update site object
            site.rewrite_template = templateName;

            // Regenerate config
            if (!onlyDb) {
                await saveSiteConfig(site, appDir, dbManager);
            }

            return { success: true };
        } catch (error) {
            console.error('Failed to update rewrite template:', error);
            return { error: error.message };
        }
    });

    // Get rewrite template content
    ipcMain.handle('sites-get-template-content', async (event, templateName) => {
        const templatePath = path.join(appDir, 'data', 'rewrite', `${templateName}.conf`);
        if (!fs.existsSync(templatePath)) return { error: 'Template not found' };
        try {
            const content = await fsPromises.readFile(templatePath, 'utf-8');
            return { content };
        } catch (e) {
            console.error('Get template content error:', e);
            return { error: e.message };
        }
    });

    // Open site in browser
    ipcMain.handle('sites-open-browser', async (event, domain) => {
        const { shell } = require('electron');
        await shell.openExternal(`http://${domain}`);
        return { success: true };
    });

    // Update Apache Server Root
    ipcMain.handle('sites-update-apache-root', async (event, newPath) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const apps = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', ['apache']);
            if (!apps || apps.length === 0) {
                return { error: 'Apache not installed' };
            }
            const app = apps[0];
            const execPath = path.dirname(app.exec_path); // .../Apache24/bin
            const appPath = path.dirname(execPath); // .../Apache24

            // Check for template
            const templatePath = path.join(context.appDir, 'data', 'config', 'apache.conf');
            if (!fs.existsSync(templatePath)) {
                return { error: 'Apache config template not found' };
            }

            let configContent = await fsPromises.readFile(templatePath, 'utf-8');

            // Prepare paths
            const serverRootSlash = appPath.replace(/\\/g, '/');
            const htdocsPathSlash = newPath.replace(/\\/g, '/');
            const cgiBinPathSlash = path.join(appPath, 'cgi-bin').replace(/\\/g, '/');

            // Sites include path
            const sitesDir = path.join(context.appDir, 'sites');
            if (!fs.existsSync(sitesDir)) {
                await fsPromises.mkdir(sitesDir, { recursive: true });
            }
            const sitesPathSlash = path.join(sitesDir, '*.conf').replace(/\\/g, '/');

            // Replacements
            configContent = configContent.replace(/\[execPath\]/g, serverRootSlash);
            configContent = configContent.replace(/\[htdocsPath\]/g, htdocsPathSlash);
            configContent = configContent.replace(/\[cgiBinPath\]/g, cgiBinPathSlash);
            configContent = configContent.replace(/\[siteEnablePath\]/g, `IncludeOptional "${sitesPathSlash}"`);

            // Write to httpd.conf
            const targetPath = path.join(appPath, 'conf', 'httpd.conf');
            await fsPromises.writeFile(targetPath, configContent, 'utf-8');

            // Auto generate site
            const defaultSite = dbManager.query('SELECT * FROM settings WHERE key = ?', ['site_auto_create']);
            if (defaultSite[0].value) {
                const template = dbManager.query('SELECT * FROM settings WHERE key = ?', ['site_template']);

                // Cleanup old auto sites
                await cleanupAutoSites(dbManager, context.appDir);

                await scanDirAndAutoCreateConfig(dbManager, htdocsPathSlash, 'apache', template[0].value, context.appDir);
            }

            return { success: true };
        } catch (error) {
            console.error('Update Apache root error:', error);
            return { error: error.message };
        }
    });

    // Update Nginx Server Root
    ipcMain.handle('sites-update-nginx-root', async (event, newPath) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const apps = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', ['nginx']);
            if (!apps || apps.length === 0) {
                return { error: 'Nginx not installed' };
            }
            const app = apps[0];
            const appPath = path.dirname(app.exec_path); // .../nginx-1.x.x

            // Check for template
            const templatePath = path.join(context.appDir, 'data', 'config', 'nginx.conf');
            if (!fs.existsSync(templatePath)) {
                return { error: 'Nginx config template not found' };
            }

            let configContent = await fsPromises.readFile(templatePath, 'utf-8');

            // Prepare paths
            const htdocsPathSlash = newPath.replace(/\\/g, '/');

            // Sites include path
            const sitesDir = path.join(context.appDir, 'sites');
            if (!fs.existsSync(sitesDir)) {
                await fsPromises.mkdir(sitesDir, { recursive: true });
            }
            const sitesPathSlash = path.join(sitesDir, '*.conf').replace(/\\/g, '/');

            // Replacements
            // Update [siteEnablePath]
            configContent = configContent.replace(/\[siteEnablePath\]/g, `include "${sitesPathSlash}";`);

            // Update default root "root html;" -> "root newPath;"
            // We use a regex to ensure we match the 'root' directive inside location / or server block
            configContent = configContent.replace(/root\s+html;/g, `root "${htdocsPathSlash}";`);

            // Write to nginx.conf
            const targetPath = path.join(appPath, 'conf', 'nginx.conf');
            await fsPromises.writeFile(targetPath, configContent, 'utf-8');

            // Auto generate site
            const defaultSite = dbManager.query('SELECT * FROM settings WHERE key = ?', ['site_auto_create']);
            if (defaultSite[0].value) {
                const template = dbManager.query('SELECT * FROM settings WHERE key = ?', ['site_template']);

                // Cleanup old auto sites
                await cleanupAutoSites(dbManager, context.appDir);

                await scanDirAndAutoCreateConfig(dbManager, htdocsPathSlash, 'nginx', template[0].value, context.appDir);
            }

            return { success: true };
        } catch (error) {
            console.error('Update Nginx root error:', error);
            return { error: error.message };
        }
    });


}

/**
 * Get config file path for a site
 */
function getConfigPath(site, appDir) {
    const sitesConfigDir = path.join(appDir, 'sites');
    if (!fs.existsSync(sitesConfigDir)) {
        fs.mkdirSync(sitesConfigDir, { recursive: true });
    }

    const ext = site.webserver === 'apache' ? '.conf' : '.conf';
    return path.join(sitesConfigDir, `${site.domain}${ext}`);
}

/**
 * Parse FastCGI address from custom_args (e.g., "-b 127.0.0.1:9084" -> "127.0.0.1:9084")
 */
function parseFastcgiAddress(customArgs) {
    if (!customArgs) return '127.0.0.1:9000';

    // Match -b followed by an address like 127.0.0.1:9084
    const match = customArgs.match(/-b\s+([\d.]+:\d+)/);
    return match ? match[1] : '127.0.0.1:9000';
}

/**
 * Sanitize PHP version (e.g., "8.2.10" -> "8.2")
 */
function sanitizePhpVersion(version) {
    if (!version) return version;
    const match = version.toString().match(/^(\d+\.\d+)/);
    return match ? match[1] : version;
}

/**
 * Save site config file
 * @param {Object} site - Site configuration
 * @param {string} appDir - Application directory
 * @param {Object} dbManager - Database manager (optional, needed for PHP sites)
 */
async function saveSiteConfig(site, appDir, dbManager = null) {
    const configPath = getConfigPath(site, appDir);

    // Get FastCGI address for PHP sites
    let fastcgiAddress = '127.0.0.1:9000';
    if (site.type === 'php' && dbManager && site.php_version) {
        // Find PHP app by version and get custom_args
        const phpApps = dbManager.query('SELECT * FROM installed_apps WHERE app_id LIKE ?', [`php%`]);
        if (phpApps && phpApps.length > 0) {
            // Try to match by version
            const matchedPhp = phpApps.find(app => {
                const appVersion = app.installed_version || '';
                return appVersion.startsWith(site.php_version) || app.app_id.includes(site.php_version.replace('.', ''));
            });

            if (matchedPhp) {
                if (matchedPhp.custom_args) {
                    fastcgiAddress = parseFastcgiAddress(matchedPhp.custom_args);
                } else {
                    // Fallback to apps.json if custom_args is missing in DB
                    try {
                        const appsJsonPath = path.join(appDir, 'data', 'apps.json');
                        if (fs.existsSync(appsJsonPath)) {
                            const appsData = JSON.parse(fs.readFileSync(appsJsonPath, 'utf-8'));
                            const jsonApp = appsData.apps.find(a => a.id === matchedPhp.app_id);
                            if (jsonApp && jsonApp.default_args) {
                                fastcgiAddress = parseFastcgiAddress(jsonApp.default_args);
                            }
                        }
                    } catch (e) {
                        console.error('Failed to read apps.json fallback:', e);
                    }
                }
            } else if (phpApps[0] && phpApps[0].custom_args) {
                // Fallback to first PHP if no match
                fastcgiAddress = parseFastcgiAddress(phpApps[0].custom_args);
            }
        }
    }

    let config;
    if (site.webserver === 'apache') {
        config = generateApacheConfig(site, fastcgiAddress);
    } else {
        let rewriteRules = '';
        if (site.type === 'php') {
            const templateName = site.rewrite_template || 'default';
            const templatePath = path.join(appDir, 'data', 'rewrite', `${templateName}.conf`);
            try {
                if (fs.existsSync(templatePath)) {
                    rewriteRules = await fsPromises.readFile(templatePath, 'utf-8');
                } else {
                    const defaultPath = path.join(appDir, 'data', 'rewrite', 'default.conf');
                    if (fs.existsSync(defaultPath)) {
                        rewriteRules = await fsPromises.readFile(defaultPath, 'utf-8');
                    }
                }
            } catch (e) {
                console.error('Read rewrite template error', e);
            }
        }
        config = generateNginxConfig(site, fastcgiAddress, rewriteRules);
    }

    await fsPromises.writeFile(configPath, config, 'utf-8');
    return configPath;
}

/**
 * Delete site config file
 */
async function deleteSiteConfig(site, appDir) {
    const configPath = getConfigPath(site, appDir);
    if (fs.existsSync(configPath)) {
        await fsPromises.unlink(configPath);
    }
}


/**
 * Scan dir and auto create config
 */
async function scanDirAndAutoCreateConfig(dbManager, dir, webserver, template, appDir) {
    try {
        const files = await fsPromises.readdir(dir);
        // Get default PHP version
        const defaultPhp = dbManager.query('SELECT * FROM settings WHERE key = ?', ['default_php_version']);
        let phpVersion = (defaultPhp && defaultPhp.length > 0) ? defaultPhp[0].value : '8.2';
        phpVersion = sanitizePhpVersion(phpVersion);

        const newDomains = [];
        for (const file of files) {
            const filePath = path.join(dir, file);
            const stats = await fsPromises.stat(filePath);
            if (stats.isDirectory()) {
                const config = {
                    name: file,
                    domain: template.replace('[site]', file),
                    type: 'php',
                    root_path: filePath,
                    php_version: phpVersion
                };
                await saveSiteConfig(config, appDir, dbManager);
                // Insert into database
                dbManager.query('INSERT INTO sites (webserver, name, domain, type, root_path, is_auto, php_version) VALUES (?, ?, ?, ?, ?, 1, ?)',
                    [webserver, config.name, config.domain, config.type, config.root_path, config.php_version]);
                newDomains.push(config.domain);
            }
        }

        // Add all new domains to hosts file
        if (newDomains.length > 0) {
            await addHosts(newDomains);
        }

        return { success: true };
    } catch (error) {
        console.error('Scan dir and auto create config error:', error);
        return { error: error.message };
    }
}


/**
 * Cleanup auto created sites
 */
async function cleanupAutoSites(dbManager, appDir) {
    try {
        const sites = dbManager.query('SELECT * FROM sites WHERE is_auto = 1');
        if (sites && sites.length > 0) {
            const domainsToRemove = [];
            for (const site of sites) {
                await deleteSiteConfig(site, appDir);
                domainsToRemove.push(site.domain);
            }

            // Remove from hosts file
            if (domainsToRemove.length > 0) {
                await removeHosts(domainsToRemove);
            }

            dbManager.query('DELETE FROM sites WHERE is_auto = 1');
        }
    } catch (error) {
        console.error('Cleanup auto sites error:', error);
    }
}

module.exports = { register, runningNodeProcesses };
