/**
 * Sites Handler - IPC handlers for Website/Project management
 * Handles: PHP Projects, Node Projects, Proxy Projects
 * Supports both Nginx and Apache
 */

const fs = require('fs');
const fsPromises = require('fs').promises;
const path = require('path');
const { spawn, exec } = require('child_process');

// Store running Node processes
const runningNodeProcesses = new Map();

/**
 * Generate Nginx config for a site
 */
function generateNginxConfig(site, phpPath = null) {
    const { domain, type, root_path, port, php_version, proxy_target } = site;

    let config = `# Site: ${site.name}
# Domain: ${domain}
# Type: ${type}
# Generated by Dev-Env

server {
    listen 80;
    server_name ${domain};
`;

    if (type === 'php') {
        config += `
    root "${root_path.replace(/\\/g, '/')}";
    index index.php index.html index.htm;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \\.php$ {
        fastcgi_pass 127.0.0.1:9000;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }

    location ~ /\\.ht {
        deny all;
    }
`;
    } else if (type === 'node') {
        config += `
    location / {
        proxy_pass http://127.0.0.1:${port};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
`;
    } else if (type === 'proxy') {
        config += `
    location / {
        proxy_pass ${proxy_target};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
`;
    }

    config += `}
`;
    return config;
}

/**
 * Generate Apache VirtualHost config
 */
function generateApacheConfig(site) {
    const { domain, type, root_path, port, proxy_target } = site;

    let config = `# Site: ${site.name}
# Domain: ${domain}
# Type: ${type}
# Generated by Dev-Env

<VirtualHost *:80>
    ServerName ${domain}
`;

    if (type === 'php') {
        config += `    DocumentRoot "${root_path.replace(/\\/g, '/')}"
    
    <Directory "${root_path.replace(/\\/g, '/')}">
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    <FilesMatch \\.php$>
        SetHandler "proxy:fcgi://127.0.0.1:9000"
    </FilesMatch>
`;
    } else if (type === 'node' || type === 'proxy') {
        const target = type === 'node' ? `http://127.0.0.1:${port}` : proxy_target;
        config += `    ProxyPreserveHost On
    ProxyPass / ${target}/
    ProxyPassReverse / ${target}/
`;
    }

    config += `</VirtualHost>
`;
    return config;
}

/**
 * Register sites-related IPC handlers
 */
function register(ipcMain, context) {
    const { getDbManager, appDir } = context;

    // Get list of sites
    ipcMain.handle('sites-list', async () => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites ORDER BY created_at DESC');

            // Add running status for Node projects
            for (const site of sites) {
                if (site.type === 'node') {
                    site.processRunning = runningNodeProcesses.has(site.id);
                }
            }

            return { sites: sites || [] };
        } catch (error) {
            console.error('Failed to get sites:', error);
            return { error: error.message };
        }
    });

    // Create new site
    ipcMain.handle('sites-create', async (event, siteData) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const { name, domain, type, webserver, root_path, port, php_version, node_script, proxy_target } = siteData;
            const now = new Date().toISOString();

            // Check if domain already exists
            const existing = dbManager.query('SELECT id FROM sites WHERE domain = ?', [domain]);
            if (existing && existing.length > 0) {
                return { error: 'Domain already exists' };
            }

            // Create root directory if PHP project
            if (type === 'php' && root_path) {
                if (!fs.existsSync(root_path)) {
                    await fsPromises.mkdir(root_path, { recursive: true });
                }
                // Create default index.php
                const indexPath = path.join(root_path, 'index.php');
                if (!fs.existsSync(indexPath)) {
                    await fsPromises.writeFile(indexPath, `<?php\necho '<h1>Welcome to ${name}</h1>';\nphpinfo();\n`);
                }
            }

            // Insert into database
            const result = dbManager.query(
                `INSERT INTO sites (name, domain, type, webserver, root_path, port, php_version, node_script, proxy_target, status, created_at, updated_at)
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'stopped', ?, ?)`,
                [name, domain, type, webserver, root_path || '', port || 0, php_version || '', node_script || '', proxy_target || '', now, now]
            );

            if (result.error) {
                return { error: result.error };
            }

            const siteId = result.lastInsertRowid;
            const site = { id: siteId, name, domain, type, webserver, root_path, port, php_version, node_script, proxy_target };

            // Generate and save webserver config
            await saveSiteConfig(site, appDir);

            return { success: true, id: siteId };
        } catch (error) {
            console.error('Failed to create site:', error);
            return { error: error.message };
        }
    });

    // Delete site
    ipcMain.handle('sites-delete', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            // Get site info first
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            // Stop Node process if running
            if (site.type === 'node' && runningNodeProcesses.has(siteId)) {
                const proc = runningNodeProcesses.get(siteId);
                proc.kill();
                runningNodeProcesses.delete(siteId);
            }

            // Delete config file
            await deleteSiteConfig(site, appDir);

            // Delete from database
            const result = dbManager.query('DELETE FROM sites WHERE id = ?', [siteId]);
            if (result.error) {
                return { error: result.error };
            }

            return { success: true };
        } catch (error) {
            console.error('Failed to delete site:', error);
            return { error: error.message };
        }
    });

    // Start Node project
    ipcMain.handle('sites-start-node', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            if (site.type !== 'node') {
                return { error: 'Not a Node project' };
            }

            if (runningNodeProcesses.has(siteId)) {
                return { error: 'Already running' };
            }

            // Start Node process
            const scriptPath = path.join(site.root_path, site.node_script || 'index.js');
            if (!fs.existsSync(scriptPath)) {
                return { error: `Script not found: ${scriptPath}` };
            }

            const proc = spawn('node', [scriptPath], {
                cwd: site.root_path,
                env: { ...process.env, PORT: site.port },
                stdio: 'pipe'
            });

            proc.on('error', (err) => {
                console.error(`Node process error for ${site.name}:`, err);
                runningNodeProcesses.delete(siteId);
            });

            proc.on('exit', () => {
                runningNodeProcesses.delete(siteId);
                dbManager.query('UPDATE sites SET status = ? WHERE id = ?', ['stopped', siteId]);
            });

            runningNodeProcesses.set(siteId, proc);
            dbManager.query('UPDATE sites SET status = ? WHERE id = ?', ['running', siteId]);

            return { success: true, pid: proc.pid };
        } catch (error) {
            console.error('Failed to start Node project:', error);
            return { error: error.message };
        }
    });

    // Stop Node project
    ipcMain.handle('sites-stop-node', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            if (!runningNodeProcesses.has(siteId)) {
                return { error: 'Not running' };
            }

            const proc = runningNodeProcesses.get(siteId);
            proc.kill();
            runningNodeProcesses.delete(siteId);

            dbManager.query('UPDATE sites SET status = ? WHERE id = ?', ['stopped', siteId]);

            return { success: true };
        } catch (error) {
            console.error('Failed to stop Node project:', error);
            return { error: error.message };
        }
    });

    // Get site config content
    ipcMain.handle('sites-get-config', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            const configPath = getConfigPath(site, appDir);
            if (!fs.existsSync(configPath)) {
                return { error: 'Config file not found' };
            }

            const content = await fsPromises.readFile(configPath, 'utf-8');
            return { content, path: configPath };
        } catch (error) {
            console.error('Failed to get site config:', error);
            return { error: error.message };
        }
    });

    // Save site config content
    ipcMain.handle('sites-save-config', async (event, siteId, content) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            const configPath = getConfigPath(site, appDir);
            await fsPromises.writeFile(configPath, content, 'utf-8');

            return { success: true };
        } catch (error) {
            console.error('Failed to save site config:', error);
            return { error: error.message };
        }
    });

    // Get installed webserver
    ipcMain.handle('sites-get-webserver', async () => {
        const dbManager = getDbManager();
        if (!dbManager) return { installed: null };

        try {
            // Check installed apps for nginx or apache
            const nginx = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', ['nginx']);
            const apache = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', ['apache']);

            const result = {
                nginx: nginx && nginx.length > 0 ? nginx[0] : null,
                apache: apache && apache.length > 0 ? apache[0] : null
            };

            return result;
        } catch (error) {
            console.error('Failed to check webserver:', error);
            return { error: error.message };
        }
    });

    // Open site in browser
    ipcMain.handle('sites-open-browser', async (event, domain) => {
        const { shell } = require('electron');
        await shell.openExternal(`http://${domain}`);
        return { success: true };
    });

    // Get current server root
    ipcMain.handle('sites-get-server-root', async (event, webserverType) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            // Find installed app
            const apps = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', [webserverType]);
            if (!apps || apps.length === 0) {
                return { error: `${webserverType} not installed` };
            }
            const app = apps[0];
            const appPath = path.dirname(app.exec_path); // e.g. .../Apache24/bin -> .../Apache24

            let configPath, rootPath = '';

            if (webserverType === 'apache') {
                configPath = path.join(appPath, '../conf/httpd.conf'); // bin/../conf
                if (fs.existsSync(configPath)) {
                    const content = await fsPromises.readFile(configPath, 'utf-8');
                    const match = content.match(/ServerRoot\s+"?([^"\r\n]+)"?/);
                    if (match) rootPath = match[1];
                }
            } else if (webserverType === 'nginx') {
                // For Nginx, we check conf/sites-enabled/default
                const sitesEnabledDir = path.join(appPath, 'conf/sites-enabled');
                configPath = path.join(sitesEnabledDir, 'default');

                // Try .conf extension as well
                if (!fs.existsSync(configPath) && fs.existsSync(configPath + '.conf')) {
                    configPath += '.conf';
                }

                if (fs.existsSync(configPath)) {
                    const content = await fsPromises.readFile(configPath, 'utf-8');
                    const match = content.match(/root\s+"?([^";]+)"?;/);
                    if (match) rootPath = match[1];
                } else {
                    // Try without 'conf/' prefix (some portable nginx versions)
                    const altSitesDir = path.join(appPath, 'sites-enabled');
                    const altConfigPath = path.join(altSitesDir, 'default');

                    if (fs.existsSync(altConfigPath)) {
                        configPath = altConfigPath;
                    } else if (fs.existsSync(altConfigPath + '.conf')) {
                        configPath = altConfigPath + '.conf';
                    }

                    if (fs.existsSync(configPath)) {
                        const content = await fsPromises.readFile(configPath, 'utf-8');
                        const match = content.match(/root\s+"?([^";]+)"?;/);
                        if (match) rootPath = match[1];
                    }
                }
            }

            return { path: rootPath, configPath };
        } catch (error) {
            return { error: error.message };
        }
    });

    // Update server root
    ipcMain.handle('sites-update-server-root', async (event, webserverType, newPath) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const apps = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', [webserverType]);
            if (!apps || apps.length === 0) {
                return { error: `${webserverType} not installed` };
            }
            const app = apps[0];
            const appPath = path.dirname(app.exec_path);

            const newPathNormalized = newPath.replace(/\\/g, '/');

            if (webserverType === 'apache') {
                const configPath = path.join(appPath, '../conf/httpd.conf');
                if (!fs.existsSync(configPath)) {
                    return { error: 'Config file not found' };
                }

                let content = await fsPromises.readFile(configPath, 'utf-8');

                // Replace ServerRoot
                const regex = /ServerRoot\s+"?([^"\r\n]+)"?/g;
                if (regex.test(content)) {
                    content = content.replace(regex, `ServerRoot "${newPathNormalized}"`);
                    await fsPromises.writeFile(configPath, content, 'utf-8');
                    return { success: true };
                } else {
                    return { error: 'ServerRoot directive not found' };
                }
            } else if (webserverType === 'nginx') {
                // Target: conf/sites-enabled/default
                let sitesEnabledDir = path.join(appPath, 'conf/sites-enabled');

                // If conf/sites-enabled doesn't exist, check sites-enabled root
                if (!fs.existsSync(sitesEnabledDir) && !fs.existsSync(path.dirname(sitesEnabledDir))) {
                    // If conf/ doesn't exist? Unlikely for nginx.
                    // But maybe sites-enabled is in root
                    if (fs.existsSync(path.join(appPath, 'sites-enabled'))) {
                        sitesEnabledDir = path.join(appPath, 'sites-enabled');
                    }
                }

                if (!fs.existsSync(sitesEnabledDir)) {
                    await fsPromises.mkdir(sitesEnabledDir, { recursive: true });
                }

                // Use 'default' (no ext) as requested, unless .conf exists
                let configPath = path.join(sitesEnabledDir, 'default');
                if (fs.existsSync(configPath + '.conf')) configPath += '.conf';

                let content = '';
                if (fs.existsSync(configPath)) {
                    content = await fsPromises.readFile(configPath, 'utf-8');
                    const regex = /root\s+["']?([^;"']+)["']?;/g;
                    if (regex.test(content)) {
                        content = content.replace(regex, `root "${newPathNormalized}";`);
                    } else {
                        // Append if missing (risky structure) or replace entire file?
                        // Better to assume valid config or overwrite
                        content = generateDefaultNginxConfig(newPathNormalized);
                    }
                } else {
                    content = generateDefaultNginxConfig(newPathNormalized);
                }

                await fsPromises.writeFile(configPath, content, 'utf-8');
                return { success: true };
            }

            return { error: 'Unsupported webserver type' };
        } catch (error) {
            console.error('Update server root error:', error);
            return { error: error.message };
        }
    });
}

/**
 * Get config file path for a site
 */
function getConfigPath(site, appDir) {
    const sitesConfigDir = path.join(appDir, 'sites');
    if (!fs.existsSync(sitesConfigDir)) {
        fs.mkdirSync(sitesConfigDir, { recursive: true });
    }

    const ext = site.webserver === 'apache' ? '.conf' : '.conf';
    return path.join(sitesConfigDir, `${site.domain}${ext}`);
}

/**
 * Save site config file
 */
async function saveSiteConfig(site, appDir) {
    const configPath = getConfigPath(site, appDir);

    let config;
    if (site.webserver === 'apache') {
        config = generateApacheConfig(site);
    } else {
        config = generateNginxConfig(site);
    }

    await fsPromises.writeFile(configPath, config, 'utf-8');
    return configPath;
}

/**
 * Delete site config file
 */
async function deleteSiteConfig(site, appDir) {
    const configPath = getConfigPath(site, appDir);
    if (fs.existsSync(configPath)) {
        await fsPromises.unlink(configPath);
    }
}

/**
 * Generate default nginx config
 */
function generateDefaultNginxConfig(rootPath) {
    return `server {
    listen 80 default_server;
    server_name localhost;
    root "${rootPath}";
    index index.php index.html index.htm;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \\.php$ {
        fastcgi_pass 127.0.0.1:9000;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}`;
}

module.exports = { register, runningNodeProcesses };
