/**
 * Sites Handler - IPC handlers for Website/Project management
 * Handles: PHP Projects, Node Projects, Proxy Projects
 * Supports both Nginx and Apache
 */

const fs = require('fs');
const fsPromises = require('fs').promises;
const path = require('path');
const { spawn, exec } = require('child_process');
const { addHosts, removeHosts } = require('./hostsHandler');
const { getAppServiceStatus, stopAppService, startAppService } = require('./serviceHandler');
const sslHandler = require('./sslHandler');

// Store running Node processes
const runningNodeProcesses = new Map();

// Import logApp from appsHandler (shared logging)
let logAppFn = null;

function logApp(message, type = 'INFO') {
    if (logAppFn) {
        logAppFn(message, type);
    } else {
        console.log(`${type}: ${message}`);
    }
}

/**
 * Escape special characters for use in RegExp
 */
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Generate Nginx config for a site
 * @param {Object} site - Site configuration
 * @param {string} fastcgiAddress - FastCGI address (e.g., 127.0.0.1:9000)
 * @param {string} rewriteRules - Nginx rewrite rules content
 * @param {Object} sslPaths - SSL certificate paths { certPath, keyPath }
 */
function generateNginxConfig(site, fastcgiAddress = '127.0.0.1:9000', rewriteRules = '', sslPaths = null) {
    const { domain, type, root_path, port, php_version, proxy_target } = site;
    const hasSSL = sslPaths && sslPaths.certPath && sslPaths.keyPath;

    let config = `# Site: ${site.name}
# Domain: ${domain}
# Type: ${type}
# Generated by Dev-Env

`;

    // HTTP server block - redirect to HTTPS if SSL available
    if (hasSSL) {
        config += `server {
    listen 80;
    server_name ${domain};
    return 301 https://$server_name$request_uri;
}

`;
    }

    // Main server block (HTTPS if SSL, HTTP otherwise)
    config += `server {
    listen ${hasSSL ? '443 ssl' : '80'};
    server_name ${domain};
`;

    // SSL configuration
    if (hasSSL) {
        config += `
    ssl_certificate "${sslPaths.certPath.replace(/\\/g, '/')}";
    ssl_certificate_key "${sslPaths.keyPath.replace(/\\/g, '/')}";
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
`;
    }

    if (type === 'php') {
        config += `
    root "${root_path.replace(/\\/g, '/')}";
    index index.php index.html index.htm;

    access_log logs/${domain}.access.log;
    error_log logs/${domain}.error.log;

    # Rewrite Rules
    ${rewriteRules || ''}
    # End Rewrite Rules
    
    location ~ \\.php$ {
        fastcgi_pass ${fastcgiAddress};
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }

    location ~ /\\.ht {
        deny all;
    }
`;
    } else if (type === 'node') {
        config += `
    location / {
        proxy_pass http://127.0.0.1:${port};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
`;
    } else if (type === 'proxy') {
        config += `
    location / {
        proxy_pass ${proxy_target};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
`;
    }

    config += `}
`;
    return config;
}

/**
 * Generate Apache VirtualHost config
 * @param {Object} site - Site configuration
 * @param {string} fastcgiAddress - FastCGI address (e.g., 127.0.0.1:9000)
 * @param {Object} sslPaths - SSL certificate paths { certPath, keyPath }
 */
function generateApacheConfig(site, fastcgiAddress = '127.0.0.1:9000', sslPaths = null) {
    const { domain, type, root_path, port, proxy_target } = site;
    const hasSSL = sslPaths && sslPaths.certPath && sslPaths.keyPath;

    let config = `# Site: ${site.name}
# Domain: ${domain}
# Type: ${type}
# Generated by Dev-Env

`;

    // HTTP VirtualHost - redirect to HTTPS if SSL available
    if (hasSSL) {
        config += `<VirtualHost *:80>
    ServerName ${domain}
    Redirect permanent / https://${domain}/
</VirtualHost>

`;
    }

    // Main VirtualHost (HTTPS if SSL, HTTP otherwise)
    config += `<VirtualHost *:${hasSSL ? '443' : '80'}>
    ServerName ${domain}
`;

    // SSL configuration
    if (hasSSL) {
        config += `
    SSLEngine on
    SSLCertificateFile "${sslPaths.certPath.replace(/\\/g, '/')}"
    SSLCertificateKeyFile "${sslPaths.keyPath.replace(/\\/g, '/')}"
`;
    }

    if (type === 'php') {
        config += `    DocumentRoot "${root_path.replace(/\\/g, '/')}"

    ErrorLog  "logs/${domain}.error.log"
    CustomLog "logs/${domain}.access.log" common
    
    <Directory "${root_path.replace(/\\/g, '/')}">
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    <FilesMatch \\.php$>
        SetHandler "proxy:fcgi://${fastcgiAddress}"
    </FilesMatch>
`;
    } else if (type === 'node' || type === 'proxy') {
        const target = type === 'node' ? `http://127.0.0.1:${port}` : proxy_target;
        config += `    ProxyPreserveHost On
    ProxyPass / ${target}/
    ProxyPassReverse / ${target}/
`;
    }

    config += `</VirtualHost>
`;
    return config;
}

/**
 * Register sites-related IPC handlers
 */
function register(ipcMain, context) {
    const { getDbManager, appDir, userDataPath } = context;

    // Context not currently used (beyond logApp) but kept for consistency
    // Use shared logApp if provided
    if (context.logApp) {
        logAppFn = context.logApp;
    }

    // Get list of sites
    ipcMain.handle('sites-list', async () => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        // Ensure rewrite_template column exists
        try {
            const columns = dbManager.query('PRAGMA table_info(sites)');
            const hasRewrite = columns.some(col => col.name === 'rewrite_template');
            if (!hasRewrite) {
                dbManager.query('ALTER TABLE sites ADD COLUMN rewrite_template TEXT');
            }
        } catch (e) {
            console.error('Migration error:', e);
        }

        try {
            const sites = dbManager.query('SELECT * FROM sites ORDER BY created_at DESC');

            // Add running status for Node projects
            for (const site of sites) {
                if (site.type === 'node') {
                    site.processRunning = runningNodeProcesses.has(site.id);
                }
            }

            return { sites: sites || [] };
        } catch (error) {
            console.error('Failed to get sites:', error);
            return { error: error.message };
        }
    });

    // Create new site
    ipcMain.handle('sites-create', async (event, siteData) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const { name, domain, type, webserver, root_path, port, php_version, node_script, proxy_target } = siteData;
            const now = new Date().toISOString();

            // Check if domain already exists
            const existing = dbManager.query('SELECT id FROM sites WHERE domain = ?', [domain]);
            if (existing && existing.length > 0) {
                return { error: 'Domain already exists' };
            }

            // Create root directory if PHP project
            if (type === 'php' && root_path) {
                if (!fs.existsSync(root_path)) {
                    await fsPromises.mkdir(root_path, { recursive: true });
                }
                // Create default index.php
                const indexPath = path.join(root_path, 'index.php');
                if (!fs.existsSync(indexPath)) {
                    await fsPromises.writeFile(indexPath, `<?php\necho '<h1>Welcome to ${name}</h1>';\nphpinfo();\n`);
                }
            }

            // Default PHP version if not provided
            let finalPhpVersion = php_version;
            if (type === 'php') {
                if (!finalPhpVersion) {
                    const defaultPhp = dbManager.query('SELECT * FROM settings WHERE key = ?', ['default_php_version']);
                    finalPhpVersion = (defaultPhp && defaultPhp.length > 0) ? defaultPhp[0].value : '8.2';
                }
                finalPhpVersion = sanitizePhpVersion(finalPhpVersion);
            }

            // Insert into database
            const result = dbManager.query(
                `INSERT INTO sites (name, domain, type, webserver, root_path, port, php_version, node_script, proxy_target, status, created_at, updated_at)
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'stopped', ?, ?)`,
                [name, domain, type, webserver, root_path || '', port || 0, finalPhpVersion || '', node_script || '', proxy_target || '', now, now]
            );

            if (result.error) {
                return { error: result.error };
            }

            const siteId = result.lastInsertRowid;
            const site = { id: siteId, name, domain, type, webserver, root_path, port, php_version, node_script, proxy_target };

            // Generate and save webserver config
            await saveSiteConfig(site, context.userDataPath, dbManager, context.appDir);

            // Add to hosts file
            await addHosts([domain]);

            // Restart web services
            await restartWebServices(dbManager);

            return { success: true, id: siteId };
        } catch (error) {
            console.error('Failed to create site:', error);
            return { error: error.message };
        }
    });

    // Delete site
    ipcMain.handle('sites-delete', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            // Get site info first
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            // Stop Node process if running
            if (site.type === 'node' && runningNodeProcesses.has(siteId)) {
                const proc = runningNodeProcesses.get(siteId);
                proc.kill();
                runningNodeProcesses.delete(siteId);
            }

            // Delete config file
            await deleteSiteConfig(site, context.userDataPath);

            // Remove from hosts file
            await removeHosts([site.domain]);

            // Delete from database
            const result = dbManager.query('DELETE FROM sites WHERE id = ?', [siteId]);
            if (result.error) {
                return { error: result.error };
            }

            return { success: true };
        } catch (error) {
            console.error('Failed to delete site:', error);
            return { error: error.message };
        }
    });

    // Start Node project
    ipcMain.handle('sites-start-node', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            if (site.type !== 'node') {
                return { error: 'Not a Node project' };
            }

            if (runningNodeProcesses.has(siteId)) {
                return { error: 'Already running' };
            }

            // Start Node process
            const scriptPath = path.join(site.root_path, site.node_script || 'index.js');
            if (!fs.existsSync(scriptPath)) {
                return { error: `Script not found: ${scriptPath}` };
            }

            const proc = spawn('node', [scriptPath], {
                cwd: site.root_path,
                env: { ...process.env, PORT: site.port },
                stdio: 'pipe'
            });

            proc.on('error', (err) => {
                console.error(`Node process error for ${site.name}:`, err);
                runningNodeProcesses.delete(siteId);
            });

            proc.on('exit', () => {
                runningNodeProcesses.delete(siteId);
                dbManager.query('UPDATE sites SET status = ? WHERE id = ?', ['stopped', siteId]);
            });

            runningNodeProcesses.set(siteId, proc);
            dbManager.query('UPDATE sites SET status = ? WHERE id = ?', ['running', siteId]);

            return { success: true, pid: proc.pid };
        } catch (error) {
            console.error('Failed to start Node project:', error);
            return { error: error.message };
        }
    });

    // Stop Node project
    ipcMain.handle('sites-stop-node', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            if (!runningNodeProcesses.has(siteId)) {
                return { error: 'Not running' };
            }

            const proc = runningNodeProcesses.get(siteId);
            proc.kill();
            runningNodeProcesses.delete(siteId);

            dbManager.query('UPDATE sites SET status = ? WHERE id = ?', ['stopped', siteId]);

            return { success: true };
        } catch (error) {
            console.error('Failed to stop Node project:', error);
            return { error: error.message };
        }
    });

    // Get site config content
    ipcMain.handle('sites-get-config', async (event, siteId) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            const configPath = getConfigPath(site, userDataPath);
            if (!fs.existsSync(configPath)) {
                return { error: 'Config file not found' };
            }

            const content = await fsPromises.readFile(configPath, 'utf-8');
            return { content, path: configPath };
        } catch (error) {
            console.error('Failed to get site config:', error);
            return { error: error.message };
        }
    });

    // Save site config content
    ipcMain.handle('sites-save-config', async (event, siteId, content) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            const configPath = getConfigPath(site, userDataPath);
            await fsPromises.writeFile(configPath, content, 'utf-8');

            return { success: true };
        } catch (error) {
            console.error('Failed to save site config:', error);
            return { error: error.message };
        }
    });

    // Get installed webserver
    ipcMain.handle('sites-get-webserver', async () => {
        const dbManager = getDbManager();
        if (!dbManager) return { installed: null };

        try {
            // Check installed apps for nginx or apache
            const nginx = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', ['nginx']);
            const apache = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', ['apache']);

            const result = {
                nginx: nginx && nginx.length > 0 ? nginx[0] : null,
                apache: apache && apache.length > 0 ? apache[0] : null
            };

            return result;
        } catch (error) {
            console.error('Failed to check webserver:', error);
            return { error: error.message };
        }
    });

    // Get installed PHP versions
    ipcMain.handle('sites-get-php-versions', async () => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const phpApps = dbManager.query('SELECT installed_version FROM installed_apps WHERE app_id LIKE ?', [`php%`]);
            const versions = phpApps.map(app => {
                // Extract major.minor from version string (e.g., 8.2.10 -> 8.2)
                const match = app.installed_version.match(/^(\d+\.\d+)/);
                return match ? match[1] : app.installed_version;
            });
            // Unique versions
            const uniqueVersions = [...new Set(versions)].sort().reverse();
            return { versions: uniqueVersions };
        } catch (error) {
            console.error('Failed to get PHP versions:', error);
            return { error: error.message };
        }
    });

    // Update site PHP version
    ipcMain.handle('sites-update-php', async (event, siteId, phpVersion) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            if (site.type !== 'php') {
                return { error: 'Not a PHP site' };
            }

            phpVersion = sanitizePhpVersion(phpVersion);

            // Update database
            dbManager.query('UPDATE sites SET php_version = ?, updated_at = ? WHERE id = ?', [phpVersion, new Date().toISOString(), siteId]);

            // Update site object
            site.php_version = phpVersion;

            // Regenerate config (userDataPath for writable, appDir for templates)
            await saveSiteConfig(site, userDataPath, dbManager, appDir);

            return { success: true };
        } catch (error) {
            console.error('Failed to update PHP version:', error);
            return { error: error.message };
        }
    });

    // Get rewrite templates
    ipcMain.handle('sites-get-rewrite-templates', async () => {
        const rewriteDir = path.join(appDir, 'data', 'rewrite');
        if (!fs.existsSync(rewriteDir)) return { templates: {} };

        try {
            const files = await fsPromises.readdir(rewriteDir);
            const templates = {};
            for (const file of files) {
                if (file.endsWith('.conf')) {
                    const name = file.replace('.conf', '');
                    templates[name] = { name: name };
                }
            }
            return { templates };
        } catch (e) {
            console.error('Get rewrite templates error', e);
            return { templates: {} };
        }
    });

    // Update site rewrite template
    ipcMain.handle('sites-update-rewrite', async (event, siteId, templateName, onlyDb = false) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites WHERE id = ?', [siteId]);
            if (!sites || sites.length === 0) {
                return { error: 'Site not found' };
            }
            const site = sites[0];

            if (site.type !== 'php') {
                return { error: 'Not a PHP site' };
            }

            const templatePath = path.join(appDir, 'data', 'rewrite', `${templateName}.conf`);
            if (!fs.existsSync(templatePath)) {
                return { error: 'Invalid template' };
            }

            // Update database
            dbManager.query('UPDATE sites SET rewrite_template = ?, updated_at = ? WHERE id = ?', [templateName, new Date().toISOString(), siteId]);

            // Update site object
            site.rewrite_template = templateName;

            // Regenerate config (userDataPath for writable, appDir for templates)
            if (!onlyDb) {
                await saveSiteConfig(site, userDataPath, dbManager, appDir);
            }

            return { success: true };
        } catch (error) {
            console.error('Failed to update rewrite template:', error);
            return { error: error.message };
        }
    });

    // Get rewrite template content
    ipcMain.handle('sites-get-template-content', async (event, templateName) => {
        const templatePath = path.join(appDir, 'data', 'rewrite', `${templateName}.conf`);
        if (!fs.existsSync(templatePath)) return { error: 'Template not found' };
        try {
            const content = await fsPromises.readFile(templatePath, 'utf-8');
            return { content };
        } catch (e) {
            console.error('Get template content error:', e);
            return { error: e.message };
        }
    });

    // Open site in browser
    ipcMain.handle('sites-open-browser', async (event, urlOrDomain) => {
        const { shell } = require('electron');
        let target = urlOrDomain;
        if (!target.startsWith('http://') && !target.startsWith('https://')) {
            target = `http://${target}`;
        }
        await shell.openExternal(target);
        return { success: true };
    });

    // Update Apache Server Root
    ipcMain.handle('sites-update-apache-root', async (event, newPath) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const apps = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', ['apache']);
            if (!apps || apps.length === 0) {
                return { error: 'Apache not installed' };
            }
            const app = apps[0];
            const execPath = path.dirname(app.exec_path); // .../Apache24/bin
            const appPath = path.dirname(execPath); // .../Apache24

            // Check for template
            const templatePath = path.join(context.appDir, 'data', 'config', 'apache.conf');
            if (!fs.existsSync(templatePath)) {
                return { error: 'Apache config template not found' };
            }

            let configContent = await fsPromises.readFile(templatePath, 'utf-8');

            // Prepare paths
            const serverRootSlash = appPath.replace(/\\/g, '/');
            const htdocsPathSlash = newPath.replace(/\\/g, '/');
            const cgiBinPathSlash = path.join(appPath, 'cgi-bin').replace(/\\/g, '/');

            // Sites include path (use userDataPath for writable directories)
            const sitesDir = path.join(context.userDataPath, 'sites');
            if (!fs.existsSync(sitesDir)) {
                await fsPromises.mkdir(sitesDir, { recursive: true });
            }
            const sitesPathSlash = path.join(sitesDir, '*.conf').replace(/\\/g, '/');

            // static app path (use userDataPath for writable directories)
            const staticAppPath = path.join(context.userDataPath, 'static', 'apache');
            if (!fs.existsSync(staticAppPath)) {
                await fsPromises.mkdir(staticAppPath, { recursive: true });
            }
            const staticAppPathSlash = path.join(staticAppPath, '*.conf').replace(/\\/g, '/');

            // Replacements
            configContent = configContent.replace(/\[execPath\]/g, serverRootSlash);
            configContent = configContent.replace(/\[htdocsPath\]/g, htdocsPathSlash);
            configContent = configContent.replace(/\[cgiBinPath\]/g, cgiBinPathSlash);
            configContent = configContent.replace(/\[siteEnablePath\]/g, `IncludeOptional "${sitesPathSlash}"`);
            configContent = configContent.replace(/\[staticAppPath\]/g, `IncludeOptional "${staticAppPathSlash}"`);

            // Write to httpd.conf
            const targetPath = path.join(appPath, 'conf', 'httpd.conf');
            await fsPromises.writeFile(targetPath, configContent, 'utf-8');

            // Auto generate site
            const defaultSite = dbManager.query('SELECT * FROM settings WHERE key = ?', ['site_auto_create']);
            if (defaultSite[0].value) {
                const template = dbManager.query('SELECT * FROM settings WHERE key = ?', ['site_template']);

                // Cleanup old auto sites
                await cleanupAutoSites(dbManager, context.userDataPath);

                await scanDirAndAutoCreateConfig(dbManager, htdocsPathSlash, 'apache', template[0].value, context.userDataPath, context.appDir);
            }

            return { success: true };
        } catch (error) {
            console.error('Update Apache root error:', error);
            return { error: error.message };
        }
    });

    // Update Nginx Server Root
    ipcMain.handle('sites-update-nginx-root', async (event, newPath) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const apps = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', ['nginx']);
            if (!apps || apps.length === 0) {
                return { error: 'Nginx not installed' };
            }
            const app = apps[0];
            const appPath = path.dirname(app.exec_path); // .../nginx-1.x.x

            // Check for template
            const templatePath = path.join(context.appDir, 'data', 'config', 'nginx.conf');
            if (!fs.existsSync(templatePath)) {
                return { error: 'Nginx config template not found' };
            }

            let configContent = await fsPromises.readFile(templatePath, 'utf-8');

            // Prepare paths
            const htdocsPathSlash = newPath.replace(/\\/g, '/');

            // Sites include path (use userDataPath for writable directories)
            const sitesDir = path.join(context.userDataPath, 'sites');
            if (!fs.existsSync(sitesDir)) {
                await fsPromises.mkdir(sitesDir, { recursive: true });
            }
            const sitesPathSlash = path.join(sitesDir, '*.conf').replace(/\\/g, '/');
            configContent = configContent.replace(/\[siteEnablePath\]/g, `include "${sitesPathSlash}";`);

            // static app path (use userDataPath for writable directories)
            const staticAppPath = path.join(context.userDataPath, 'static', 'nginx');
            if (!fs.existsSync(staticAppPath)) {
                await fsPromises.mkdir(staticAppPath, { recursive: true });
            }
            const staticAppPathSlash = path.join(staticAppPath, '*.conf').replace(/\\/g, '/');
            configContent = configContent.replace(/\[staticAppPath\]/g, `include "${staticAppPathSlash}";`);

            // Update default root "root html;" -> "root newPath;"
            // We use a regex to ensure we match the 'root' directive inside location / or server block
            configContent = configContent.replace(/root\s+html;/g, `root "${htdocsPathSlash}";`);

            // Write to nginx.conf
            const targetPath = path.join(appPath, 'conf', 'nginx.conf');
            await fsPromises.writeFile(targetPath, configContent, 'utf-8');

            // Auto generate site
            const defaultSite = dbManager.query('SELECT * FROM settings WHERE key = ?', ['site_auto_create']);
            if (defaultSite[0].value) {
                const template = dbManager.query('SELECT * FROM settings WHERE key = ?', ['site_template']);

                // Cleanup old auto sites
                await cleanupAutoSites(dbManager, context.userDataPath);

                await scanDirAndAutoCreateConfig(dbManager, htdocsPathSlash, 'nginx', template[0].value, context.userDataPath, context.appDir);
            }

            return { success: true };
        } catch (error) {
            console.error('Update Nginx root error:', error);
            return { error: error.message };
        }
    });

    // Update all sites when template changes
    ipcMain.handle('sites-update-template', async (event, oldTemplate, newTemplate) => {
        const dbManager = getDbManager();
        if (!dbManager) return { error: 'Database not initialized' };

        try {
            const sites = dbManager.query('SELECT * FROM sites');
            if (!sites || sites.length === 0) {
                return { success: true, updated: [], message: 'No sites to update' };
            }

            const updated = [];
            const failed = [];
            const oldDomains = [];
            const newDomains = [];

            for (const site of sites) {
                try {
                    // Calculate new domain based on site name and new template
                    const newDomain = newTemplate.replace('[site]', site.name);
                    const oldDomain = site.domain;

                    // Skip if domain is already the same
                    if (oldDomain === newDomain) {
                        continue;
                    }

                    // Check if new domain already exists (conflict)
                    const existing = dbManager.query('SELECT id FROM sites WHERE domain = ? AND id != ?', [newDomain, site.id]);
                    if (existing && existing.length > 0) {
                        failed.push({
                            site: site.name,
                            oldDomain,
                            newDomain,
                            reason: 'Domain conflict - already exists'
                        });
                        continue;
                    }

                    // Get old config path (use userDataPath for writable directory)
                    const sitesConfigDir = path.join(userDataPath, 'sites');
                    const oldConfigPath = path.join(sitesConfigDir, `${oldDomain}.conf`);

                    // Delete old config file if exists
                    if (fs.existsSync(oldConfigPath)) {
                        await fsPromises.unlink(oldConfigPath);
                    }

                    // Regenerate config with new domain (this will also generate new SSL certificate)
                    const updatedSite = { ...site, domain: newDomain };
                    await saveSiteConfig(updatedSite, context.userDataPath, dbManager, appDir);

                    // Update database
                    dbManager.query('UPDATE sites SET domain = ?, updated_at = ? WHERE id = ?',
                        [newDomain, new Date().toISOString(), site.id]);

                    // Track domains for hosts file update
                    oldDomains.push(oldDomain);
                    newDomains.push(newDomain);

                    updated.push({
                        site: site.name,
                        oldDomain,
                        newDomain
                    });

                } catch (siteError) {
                    console.error(`Failed to update site ${site.name}:`, siteError);
                    logApp(`Failed to update site ${site.name}: ${siteError.message}`, 'ERROR');
                    failed.push({
                        site: site.name,
                        oldDomain: site.domain,
                        reason: siteError.message
                    });
                }
            }

            // Update hosts file
            if (oldDomains.length > 0) {
                await removeHosts(oldDomains);
            }
            if (newDomains.length > 0) {
                await addHosts(newDomains);
            }

            // Restart web services
            if (updated.length > 0) {
                await restartWebServices(dbManager);
            }

            return {
                success: true,
                updated,
                failed,
                message: `Updated ${updated.length} sites${failed.length > 0 ? `, ${failed.length} failed` : ''}`
            };

        } catch (error) {
            console.error('Update template error:', error);
            return { error: error.message };
        }
    });


}

/**
 * Get config file path for a site
 */
function getConfigPath(site, appDir) {
    const sitesConfigDir = path.join(appDir, 'sites');
    if (!fs.existsSync(sitesConfigDir)) {
        fs.mkdirSync(sitesConfigDir, { recursive: true });
    }

    const ext = site.webserver === 'apache' ? '.conf' : '.conf';
    return path.join(sitesConfigDir, `${site.domain}${ext}`);
}

/**
 * Parse FastCGI address from custom_args (e.g., "-b 127.0.0.1:9084" -> "127.0.0.1:9084")
 */
function parseFastcgiAddress(customArgs) {
    if (!customArgs) return '127.0.0.1:9000';

    // Match -b followed by an address like 127.0.0.1:9084
    const match = customArgs.match(/-b\s+([\d.]+:\d+)/);
    return match ? match[1] : '127.0.0.1:9000';
}

/**
 * Sanitize PHP version (e.g., "8.2.10" -> "8.2")
 */
function sanitizePhpVersion(version) {
    if (!version) return version;
    const match = version.toString().match(/^(\d+\.\d+)/);
    return match ? match[1] : version;
}

/**
 * Save site config file
 * @param {Object} site - Site configuration
 * @param {string} appDir - Application directory (for templates)
 * @param {Object} dbManager - Database manager (optional, needed for PHP sites)
 */
async function saveSiteConfig(site, userDataPath, dbManager = null, appDir = null) {
    const configPath = getConfigPath(site, userDataPath);

    // Get FastCGI address for PHP sites
    let fastcgiAddress = '127.0.0.1:9000';
    if (site.type === 'php' && dbManager && site.php_version) {
        // Find PHP app by version and get custom_args
        const phpApps = dbManager.query('SELECT * FROM installed_apps WHERE app_id LIKE ?', [`php%`]);
        if (phpApps && phpApps.length > 0) {
            // Try to match by version
            const matchedPhp = phpApps.find(app => {
                const appVersion = app.installed_version || '';
                return appVersion.startsWith(site.php_version) || app.app_id.includes(site.php_version.replace('.', ''));
            });

            if (matchedPhp) {
                if (matchedPhp.custom_args) {
                    fastcgiAddress = parseFastcgiAddress(matchedPhp.custom_args);
                } else {
                    // Fallback to apps.json if custom_args is missing in DB
                    try {
                        // Use userDataPath for apps.json as it is the active one
                        const appsJsonPath = path.join(userDataPath, 'data', 'apps.json');
                        if (fs.existsSync(appsJsonPath)) {
                            const appsData = JSON.parse(fs.readFileSync(appsJsonPath, 'utf-8'));
                            const jsonApp = appsData.apps.find(a => a.id === matchedPhp.app_id);
                            if (jsonApp && jsonApp.default_args) {
                                fastcgiAddress = parseFastcgiAddress(jsonApp.default_args);
                            }
                        }
                    } catch (e) {
                        console.error('Failed to read apps.json fallback:', e);
                    }
                }
            } else if (phpApps[0] && phpApps[0].custom_args) {
                // Fallback to first PHP if no match
                fastcgiAddress = parseFastcgiAddress(phpApps[0].custom_args);
            }
        }
    }

    // Generate SSL certificate for the domain
    let sslPaths = null;
    try {
        const sslResult = await sslHandler.generateCertificate(site.domain);
        if (sslResult.success) {
            sslPaths = {
                certPath: sslResult.certPath,
                keyPath: sslResult.keyPath
            };
            logApp(`SSL certificate generated for ${site.domain}`, 'INFO');
        } else {
            logApp(`Failed to generate SSL certificate for ${site.domain}: ${sslResult.error}`, 'WARN');
        }
    } catch (sslError) {
        logApp(`SSL certificate generation error for ${site.domain}: ${sslError.message}`, 'WARN');
    }

    let config;
    if (site.webserver === 'apache') {
        config = generateApacheConfig(site, fastcgiAddress, sslPaths);
    } else {
        let rewriteRules = '';
        if (site.type === 'php') {
            const templateName = site.rewrite_template || 'default';
            // Templates are in resource path (appDir)
            const templatePath = path.join(appDir || userDataPath, 'data', 'rewrite', `${templateName}.conf`);
            try {
                if (fs.existsSync(templatePath)) {
                    rewriteRules = await fsPromises.readFile(templatePath, 'utf-8');
                } else {
                    const defaultPath = path.join(appDir || userDataPath, 'data', 'rewrite', 'default.conf');
                    if (fs.existsSync(defaultPath)) {
                        rewriteRules = await fsPromises.readFile(defaultPath, 'utf-8');
                    }
                }
            } catch (e) {
                console.error('Read rewrite template error', e);
            }
        }
        config = generateNginxConfig(site, fastcgiAddress, rewriteRules, sslPaths);
    }

    await fsPromises.writeFile(configPath, config, 'utf-8');
    return configPath;
}

/**
 * Delete site config file
 */
async function deleteSiteConfig(site, userDataPath) {
    const configPath = getConfigPath(site, userDataPath);
    if (fs.existsSync(configPath)) {
        await fsPromises.unlink(configPath);
    }
}


/**
 * Scan dir and auto create config
 */
async function scanDirAndAutoCreateConfig(dbManager, dir, webserver, template, userDataPath, appDir) {
    try {
        const files = await fsPromises.readdir(dir);
        // Get default PHP version
        const defaultPhp = dbManager.query('SELECT * FROM settings WHERE key = ?', ['default_php_version']);
        let phpVersion = (defaultPhp && defaultPhp.length > 0) ? defaultPhp[0].value : '8.2';
        phpVersion = sanitizePhpVersion(phpVersion);

        const newDomains = [];
        for (const file of files) {
            const filePath = path.join(dir, file);
            const stats = await fsPromises.stat(filePath);
            if (stats.isDirectory()) {
                let rootPath = filePath;
                // Auto-detect public folder
                if (fs.existsSync(path.join(filePath, 'public', 'index.php'))) {
                    rootPath = path.join(filePath, 'public');
                }

                const config = {
                    name: file,
                    domain: template.replace('[site]', file),
                    type: 'php',
                    root_path: rootPath,
                    php_version: phpVersion
                };
                await saveSiteConfig(config, userDataPath, dbManager, appDir);
                // Insert into database
                dbManager.query('INSERT INTO sites (webserver, name, domain, type, root_path, is_auto, php_version) VALUES (?, ?, ?, ?, ?, 1, ?)',
                    [webserver, config.name, config.domain, config.type, config.root_path, config.php_version]);
                newDomains.push(config.domain);
            }
        }

        // Add all new domains to hosts file
        if (newDomains.length > 0) {
            await addHosts(newDomains);
        }

        // Restart web services
        await restartWebServices(dbManager);

        return { success: true };
    } catch (error) {
        console.error('Scan dir and auto create config error:', error);
        return { error: error.message };
    }
}


/**
 * Cleanup auto created sites
 */
async function cleanupAutoSites(dbManager, userDataPath) {
    try {
        const sites = dbManager.query('SELECT * FROM sites WHERE is_auto = 1');
        if (sites && sites.length > 0) {
            const domainsToRemove = [];
            for (const site of sites) {
                await deleteSiteConfig(site, userDataPath);
                domainsToRemove.push(site.domain);
            }

            // Remove from hosts file
            if (domainsToRemove.length > 0) {
                await removeHosts(domainsToRemove);
            }

            dbManager.query('DELETE FROM sites WHERE is_auto = 1');
        }
    } catch (error) {
        console.error('Cleanup auto sites error:', error);
    }
}

/**
 * Restart running web services (nginx/apache)
 */
async function restartWebServices(dbManager) {
    try {
        const webServices = ['nginx', 'apache'];
        for (const service of webServices) {
            const app = dbManager.query('SELECT * FROM installed_apps WHERE app_id = ?', [service]);
            if (app && app.length > 0) {
                const appData = app[0];
                const status = getAppServiceStatus(service, appData.exec_path);
                if (status.running) {
                    console.log(`Restarting ${service} to apply changes...`);
                    await stopAppService(service, appData.exec_path);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    await startAppService(service, appData.exec_path);
                }
                break;
            }
        }
    } catch (error) {
        console.error('Failed to restart web services:', error);
    }
}

module.exports = { register, runningNodeProcesses };
